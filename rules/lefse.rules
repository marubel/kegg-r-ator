from pathlib import Path
PATH_LEFSE = Path("LEfSe").resolve()

rule lefse_plot_cladogram:
    output: "{dataset}.clado.{fmt}"
    input:
        data="{dataset}.res",
        lefse=str(PATH_LEFSE)
    params:
        dpi=150
    conda: str(PATH_LEFSE / "conda_requirements.yml")
    shell:
        """
            {input.lefse}/plot_cladogram.py {input.data} {output} \
            --dpi {params.dpi} \
            --format {wildcards.fmt}
        """

# positional arguments:
#   INPUT_FILE            tab delimited input file
#   OUTPUT_FILE           the file for the output image
#
# optional arguments:
#   -h, --help            show this help message and exit
#   --feature_font_size FEATURE_FONT_SIZE
#                         the file for the output image
#   --format {png,svg,pdf}
#                         the format for the output file
#   --dpi DPI
#   --title TITLE
#   --title_font_size TITLE_FONT_SIZE
#   --class_legend_font_size CLASS_LEGEND_FONT_SIZE
#   --width WIDTH
#   --height HEIGHT       only for vertical histograms
#   --left_space LS
#   --right_space RS
#   --orientation {h,v}
#   --autoscale {0,1}
#   --background_color {k,w}
#                         set the color of the background
#   --subclades N_SCL     number of label levels to be displayed (starting from
#                         the leaves, -1 means all the levels, 1 is default )
#   --max_feature_len MAX_FEATURE_LEN
#                         Maximum length of feature strings (def 60)
#   --all_feats ALL_FEATS
#   --otu_only            Plot only species resolved OTUs (as opposed to all
#                         levels)
#   --report_features     Report important features to STDOUT
rule lefse_plot_res:
    output: "{dataset}.res.{fmt}"
    input:
        data="{dataset}.res",
        lefse=str(PATH_LEFSE)
    params:
        dpi=150
    conda: str(PATH_LEFSE / "conda_requirements.yml")
    shell:
        """
            {input.lefse}/plot_res.py {input.data} {output} \
            --dpi {params.dpi} \
            --format {wildcards.fmt}
        """

# positional arguments:
#   INPUT_FILE      the input file
#   OUTPUT_FILE     the output file containing the data for the visualization
#                   module
#
# optional arguments:
#   -h, --help      show this help message and exit
#   -o str          set the file for exporting the result (only concise textual
#                   form)
#   -a float        set the alpha value for the Anova test (default 0.05)
#   -w float        set the alpha value for the Wilcoxon test (default 0.05)
#   -l float        set the threshold on the absolute value of the logarithmic
#                   LDA score (default 2.0)
#   --nlogs int     max log influence of LDA coeff (default: 3)
#   --verbose int   verbose execution (default 0)
#   --wilc int      whether to perform the Wilcoxon step (default 1)
#   -r str          select LDA or SVM for effect size (default LDA)
#   --svm_norm int  whether to normalize the data in [0,1] for SVM feature
#                   waiting (default 1 strongly suggested)
#   -b int          set the number of bootstrap iteration for LDA (default 30)
#   -e int          set whether perform the wilcoxon test only among the
#                   subclasses with the same name (default 0)
#   -c int          set whether perform the wilcoxon test ing the Curtis's
#                   approach [BETA VERSION] (default 0)
#   -f float        set the subsampling fraction value for each bootstrap
#                   iteration (default 0.67)
#   -s {0,1,2}      set the multiple testing correction options. 0 no correction
#                   (more strict, default), 1 correction for independent
#                   comparisons, 2 correction for independent comparison
#   --min_c int     minimum number of samples per subclass for performing
#                   wilcoxon test (default 10)
#   -t str          set the title of the analysis (default input file without
#                   extension)
#   -y {0,1}        (for multiclass tasks) set whether the test is performed in
#                   a one-against-one ( 1 - more strict!) or in a one-against-
#                   all setting ( 0 - less strict) (default 0)
rule lefse_run:
    output: "{dataset}.res"
    input:
        data="{dataset}.in",
        lefse=str(PATH_LEFSE)
    params:
        log_lda_score_thresh=2.0,
        svm_norm=1,
        one_against_one=0
    conda: str(PATH_LEFSE / "conda_requirements.yml")
    shell:
        """
            {input.lefse}/run_lefse.py {input.data} {output} \
            -l {params.log_lda_score_thresh} \
            --svm_norm {params.svm_norm} \
            -y {params.one_against_one}
        """

# positional arguments:
#   INPUT_FILE            the input file, feature hierarchical level can be
#                         specified with | or . and those symbols must not be
#                         present for other reasons in the input file.
#   OUTPUT_FILE           the output file containing the data for LEfSe
#
# optional arguments:
#   -h, --help            show this help message and exit
#   --output_table OUTPUT_TABLE
#                         the formatted table in txt format
#   -f {c,r}              set whether the features are on rows (default) or on
#                         columns
#   -c [1..n_feats]       set which feature use as class (default 1)
#   -s [1..n_feats]       set which feature use as subclass (default -1 meaning
#                         no subclass)
#   -o float              set the normalization value (default -1.0 meaning no
#                         normalization)
#   -u [1..n_feats]       set which feature use as subject (default -1 meaning
#                         no subject)
#   -m {f,s}              set the policy to adopt with missin values: f removes
#                         the features with missing values, s removes samples
#                         with missing values (default f)
#   -n int                set the minimum cardinality of each subclass
#                         (subclasses with low cardinalities will be grouped
#                         together, if the cardinality is still low, no pairwise
#                         comparison will be performed with them)
#   -biom_c BIOM_CLASS    For biom input files: Set which feature use as class
#   -biom_s BIOM_SUBCLASS
#                         For biom input files: set which feature use as
#                         subclass
rule lefse_format_input:
    output: "{dataset}.in"
    input:
        data="{dataset}.txt",
        lefse=str(PATH_LEFSE)
    # In general we're using  the first row as the subject, the second row as
    # the class, and no subclass.  The -o value is taken from LEfSe's example
    # script and also matches the value chosen in the Galaxy web interface.
    params:
        c_class=2,
        s_subclass=-1,
        u_subject=1,
        o_norm=1000000
    conda: str(PATH_LEFSE / "conda_requirements.yml")
    shell:
        """
            {input.lefse}/format_input.py {input.data} {output} \
            -c {params.c_class} \
            -s {params.s_subclass} \
            -u {params.u_subject} \
            -o {params.o_norm}
        """

# Put together what LEfSe expects for its first input file: a combo of values
# matrix and extra rows for sample ID and grouping(s).  This only supports one
# class currently, no subclass.
rule lefse_gather_input:
    output:
        data="lefse-data/weights.{category}.{group}.for_lefse.tsv"
    input:
        data="all_weighted_{category}_matrix.tsv",
        metadata="shotgun_metadata_2519.csv"
    run: R("""
            source("lefse_helpers.R")
            prepare_lefse_input(
              weights_fp = "{input.data}",
              metadata_fp = "{input.metadata}",
              column_name = "{wildcards.group}",
              out_path = "{output.data}")
            """)

rule get_lefse:
    output: directory("LEfSe")
    shell: "git clone git@github.com:ressy/LEfSe.git"
